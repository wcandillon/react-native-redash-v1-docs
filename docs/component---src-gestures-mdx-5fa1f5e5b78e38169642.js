(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{b1EY:function(e,t,n){"use strict";n.r(t),n.d(t,"_frontmatter",(function(){return i})),n.d(t,"default",(function(){return o}));n("5hJT"),n("W1QL"),n("K/PF"),n("t91x"),n("75LO"),n("PJhk");var a=n("/FXl"),r=n("TjRS");n("aD51");function l(){return(l=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}var i={};void 0!==i&&i&&i===Object(i)&&Object.isExtensible(i)&&!i.hasOwnProperty("__filemeta")&&Object.defineProperty(i,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"src/gestures.mdx"}});var s={_frontmatter:i},c=r.a;function o(e){var t=e.components,n=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,["components"]);return Object(a.b)(c,l({},s,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h1",{id:"gestures"},"Gestures"),Object(a.b)("hr",null),Object(a.b)("h2",{id:"withoffset"},Object(a.b)("inlineCode",{parentName:"h2"},"withOffset()")),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-tsx"}),"export declare const withOffset: (value: Animated.Node<number>, state: Animated.Value<State>, offset?: Animated.Value<number>) => Animated.Node<number>;\n")),Object(a.b)("p",null,"Decorates animated value from the pan gesture handler so that its position is memorized accross touches."),Object(a.b)("p",null,"--"),Object(a.b)("h2",{id:"withscaleoffset"},Object(a.b)("inlineCode",{parentName:"h2"},"withScaleOffset()")),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-tsx"}),"export declare const withScaleOffset: (value: Animated.Node<number>, state: Animated.Value<State>, offset?: Animated.Value<number>) => Animated.Node<number>;\n")),Object(a.b)("p",null,"Decorates animated value from the pinch gesture handler so that its scale value is memorized accross touches.\nThis function differs from ",Object(a.b)("inlineCode",{parentName:"p"},"withOffset")," because it uses multiplication instead of additions.\nTranslations start from 0 and are added on top of each other whereas scale transformations start from 1 and are multiplied on top of each other."),Object(a.b)("hr",null),Object(a.b)("h2",{id:"onscrollevent"},Object(a.b)("inlineCode",{parentName:"h2"},"onScrollEvent()")),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-tsx"}),"export declare const onScrollEvent: (contentOffset: {\n    x?: Animated.Node<number> | undefined;\n    y?: Animated.Node<number> | undefined;\n}) => (...args: any[]) => void;\n")),Object(a.b)("p",null,"Returns a reanimated event handler for the ScrollView."),Object(a.b)("p",null,"Example usage for a vertical ",Object(a.b)("inlineCode",{parentName:"p"},"ScrollView"),"."),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-tsx"}),"<Animated.ScrollView onScroll={onScrollEvent({ y: new Value(0) })} />\n")),Object(a.b)("p",null,"And for a horizontal one."),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-tsx"}),"<Animated.ScrollView onScroll={onScrollEvent({ x: new Value(0) })} horizontal />\n")),Object(a.b)("hr",null),Object(a.b)("h2",{id:"ongestureevent"},Object(a.b)("inlineCode",{parentName:"h2"},"onGestureEvent()")),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-tsx"}),"export declare const onGestureEvent: (nativeEvent: Partial<Adaptable<GestureHandlerStateChangeNativeEvent & TapGestureHandlerEventExtra>> | Partial<Adaptable<GestureHandlerStateChangeNativeEvent & LongPressGestureHandlerEventExtra>> | Partial<Adaptable<GestureHandlerStateChangeNativeEvent & ForceTouchGestureHandlerEventExtra>> | Partial<Adaptable<GestureHandlerStateChangeNativeEvent & PanGestureHandlerEventExtra>> | Partial<Adaptable<GestureHandlerStateChangeNativeEvent & PinchGestureHandlerEventExtra>> | Partial<Adaptable<GestureHandlerStateChangeNativeEvent & RotationGestureHandlerEventExtra>> | Partial<Adaptable<GestureHandlerStateChangeNativeEvent & FlingGestureHandlerEventExtra>>) => {\n    onHandlerStateChange: (...args: any[]) => void;\n    onGestureEvent: (...args: any[]) => void;\n};\n")),Object(a.b)("p",null,"Returns a reanimated event handler for any Gesture handler event handler.\nExample usage for a vertical ",Object(a.b)("inlineCode",{parentName:"p"},"PanGestureHandler"),"."),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-tsx"}),"const translationX = new Value(0);\nconst state = new Value(State.UNDETERMINED);\nconst gestureHandler = onGestureEvent({ translationX, state });\nreturn <PanGestureHandler {...gestureHandler} />;\n")),Object(a.b)("hr",null),Object(a.b)("h2",{id:"pinchbegan"},Object(a.b)("inlineCode",{parentName:"h2"},"pinchBegan()")),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-tsx"}),"const pinchBegan: (state: Animated.Node<State>) => Animated.Node<1 | 0>;\n")),Object(a.b)("p",null,"Returns one if the state of the gesture is BEGAN. Is equivalent to ",Object(a.b)("inlineCode",{parentName:"p"},"eq(state, State.BEGAN)")," on iOS.\nOn Android, this function takes into account a small inconsistency where the ",Object(a.b)("inlineCode",{parentName:"p"},"focalX")," and ",Object(a.b)("inlineCode",{parentName:"p"},"focalY")," values are not available\nat ",Object(a.b)("inlineCode",{parentName:"p"},"BEGAN")," but rather in ",Object(a.b)("inlineCode",{parentName:"p"},"ACTIVE"),". See ",Object(a.b)("a",l({parentName:"p"},{href:"https://github.com/kmagiera/react-native-gesture-handler/issues/553"}),"https://github.com/kmagiera/react-native-gesture-handler/issues/553"),"."),Object(a.b)("p",null,"--"),Object(a.b)("h2",{id:"pinchactive"},Object(a.b)("inlineCode",{parentName:"h2"},"pinchActive()")),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-tsx"}),"const pinchActive:  (state: Animated.Node<State>, numberOfPointers: Animated.Node<number>) => Animated.Node<1 | 0>;\n")),Object(a.b)("p",null,"Returns one if the gesture is active (and doesn't overlap with ",Object(a.b)("inlineCode",{parentName:"p"},"pinchBegan"),")."),Object(a.b)("p",null,"--"),Object(a.b)("h2",{id:"pinchend"},Object(a.b)("inlineCode",{parentName:"h2"},"pinchEnd()")),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-tsx"}),"const pinchEnd:  (state: Animated.Node<State>, numberOfPointers: Animated.Node<number>) => Animated.Node<1 | 0>;\n")),Object(a.b)("p",null,"Returns one if the gesture has ended. On iOS, this is equivalent to ",Object(a.b)("inlineCode",{parentName:"p"},"eq(state, State.END)"),".\nOn Android, this function returns 1 if the gesture has ended or if it is active but the number of pointers is less than 2."),Object(a.b)("p",null,"--"),Object(a.b)("h2",{id:"pangesturehandler"},Object(a.b)("inlineCode",{parentName:"h2"},"panGestureHandler()")),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-tsx"}),"const panGestureHandler = () => { gestureHandler, translation, velocity, state }\n")),Object(a.b)("p",null,"--"),Object(a.b)("h2",{id:"pinchgesturehandler"},Object(a.b)("inlineCode",{parentName:"h2"},"pinchGestureHandler()")),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-tsx"}),"const pinchGestureHandler = () => { gestureHandler, scale, focal, state }\n")),Object(a.b)("p",null,"--"),Object(a.b)("h2",{id:"tapgesturehandler"},Object(a.b)("inlineCode",{parentName:"h2"},"tapGestureHandler()")),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-tsx"}),"const tapGestureHandler = () => { gestureHandler, state, position, absolutePosition }\n")))}void 0!==o&&o&&o===Object(o)&&Object.isExtensible(o)&&!o.hasOwnProperty("__filemeta")&&Object.defineProperty(o,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"src/gestures.mdx"}}),o.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-gestures-mdx-5fa1f5e5b78e38169642.js.map